
# 2023-06-12
class Basic_04:
    def __init__(self):
        # self.Review();
        # self.Python_Basic_01();
        # self.Python_Basic_02();
        # self.Python_Basic_03();
        self.Python_Basic_04();


    # Review
    def Review(self):
        # 불과 비교, 논리 연산자
        ## 불과 비교 연산자 사용하기
        """
        * 프로그래밍을 하다 보면 참, 거짓을 판단해야 할 때가 많습니다. 참은 무엇인가가 맞다, 거짓은 틀리다(아니다)를 표현합니다.
        * 이번에는 참(True), 거짓(False)을 나타내는 불(boolean)을 알아보겠습니다. 그리고 두 값의 관계를 판단하는 비교 연산자와 두 값의 논릿값을 판단하는 논리 연산자도 함께 알아보겠습니다.
        * 여기서 비교, 논리 연산자는 프로그래밍에서 매우 광범위하게 쓰입니다. 특히 앞으로 배울 if, while 구문을 작성할 때 비교, 논리 연산자를 자주 사용합니다.
        """
        # 불은 True, False로 표현하며 1, 3.6, 'Python'처럼 값의 일종
        can_smoke = True
        print("can_smoke", can_smoke)
        can_drink_beer = False
        print("can_drink_beer", can_drink_beer)
        """### 비교 연산자의 판단 결과
        * 파이썬에서는 비교 연산자와 논리 연산자의 판단 결과로 True, False를 사용합니다. 즉, 비교 결과가 맞으면 True, 아니면 False입니다.
        """
        """### 숫자가 같은지 다른지 비교하기
        * 이제 두 숫자가 같은지 또는 다른지 비교해보겠습니다. 두 숫자가 같은지 비교할 때는 ==(equal), 다른지 비교할 때는 !=(not equal)을 사용합니다.
        """
        """* 10과 10은 같으므로 True, 10과 5는 다르므로 True가 나옵니다. 파이썬에서 두 값이 같은지 비교할 때는 =이 아닌 ==을 사용합니다. 왜냐하면 =은 할당 연산자로 이미 사용되고 있기 때문입니다.
        ### 문자열이 같은지 다른지 비교하기
        숫자뿐만 아니라 문자열도 ==와 != 연산자로 비교할 수 있습니다. 이때 문자열은 비교할 때 대소문자를 구분합니다. 다음과 같이 단어가 같아도 대소문자가 다르면 다른 문자열로 판단합니다.
        """
        """### 부등호 사용하기
        * 부등호는 수학 시간에 배운 내용과 같습니다. 큰지, 작은지, 크거나 같은지, 작거나 같은지를 판단해봅니다.
        """
        """* 여기서 비교 기준은 첫 번째 값입니다. 따라서 첫 번째 값보다 큰지, 작은지처럼 읽습니다. 항상 이점을 기억해두세요.
        * 특히 부등호를 말로 설명할 때 >은 초과, <은 미만, >=은 이상, <=은 이하라고도 합니다. 그리고 >, <은 비교할 값과 같으면 무조건 거짓입니다. 하지만 >=, <=은 비교할 값과 같으면 참입니다. 따라서 이상, 이하는 비교할 값도 포함된다는 점이 중요합니다.
        ### 객체가 같은지 다른지 비교하기
        * 이번에는 is와 is not입니다. 같다는 ==, 다르다는 !=이 이미 있는데 왜 is, is not을 만들었을까요? is, is not도 같다, 다르다지만 ==, !=는 값 자체를 비교하고, is, is not은 객체(object)를 비교합니다.
        """
        """* 1과 1.0은 정수와 실수라는 차이점이 있지만 값은 같습니다. 따라서 ==로 비교해보면 True가 나옵니다. 하지만 1과 1.0을 is로 비교해보면 False가 나옵니다. 왜냐하면 1은 정수 객체, 1.0은 실수 객체이므로 두 객체는 서로 다르기 때문입니다. 물론 1과 1.0을 is not으로 비교하면 True가 나오겠죠?
        ## 논리 연산자 사용하기
        * 이번에는 논리 연산자를 사용해보겠습니다. 논리 연산자는 and, or, not이 있는데 먼저 and입니다.
        * `a and b`
        """
        """* and는 두 값이 모두 True라야 True입니다. 하나라도 False이면 False가 나옵니다.
        * 이번에는 or입니다.
        * `a or b`
        """
        """* or는 두 값 중 하나라도 True이면 True입니다. 두 값이 모두 False라야 False가 되죠.
        * 마지막으로 not입니다.
        * `not x`
        """
        """* not은 논릿값을 뒤집습니다. 그래서 not True는 False가 되고, not False는 True가 됩니다.
        * 여기서 and, or, not 논리 연산자가 식 하나에 들어있으면 not, and, or 순으로 판단합니다.
        """
        """* 식이 꼬여 있어서 상당히 헷갈리죠? 가장 먼저 not True와 not False를 판단하여 False and False or True가 됩니다.
        * 그다음에 False and False를 판단하여 False가 나와서 False or True가 되므로 최종 결과는 True가 됩니다.
        """
        # 이 식을 괄호로 표현하면 다음과 같은 모양이 됩니다.
        """* 순서가 헷갈릴 때는 괄호로 판단 순서를 명확히 나타내 주는 것이 좋습니다.
        ### 논리 연산자와 비교 연산자를 함께 사용하기
        """
        """* 비교 연산자로 비교한 결과를 논리 연산자로 다시 판단했습니다. 이때는 비교 연산자(is, is not, ==, !=, <, >, <=, >=)를 먼저 판단하고 논리 연산자(not, and, or)를 판단하게 됩니다
        ### 정수, 실수, 문자열을 불로 만들기
        * 정수, 실수, 문자열을 불로 만들 때는 bool을 사용하면 됩니다. 이때 정수 1은 True, 0은 False입니다. 만약 문자열의 내용이 'False'라도 불로 만들면 True입니다. 문자열의 내용 자체는 판단하지 않으며 값이 있으면 True입니다.
        """
        # 문자열
        ## 문자열 사용하기
        """
        # 문자열 'Hello, world!'를 출력
        # 한글 문자열
        #  " "(큰따옴표)로 묶기
        # '''(작은따옴표 3개)로 묶거나 \"""(큰따옴표 3개)로 묶기
        """  ### 여러 줄로 된 문자열 사용하기
        """
        * 이번에는 여러 줄로 된 문자열(multiline string)을 사용해보겠습니다. 다음과 같이 '''(작은따옴표 3개)로 시작하고 Hello, world!를 입력한 다음에 엔터 키를 누르면 다음 줄로 이동합니다. 이런 방식으로 문자열을 계속 입력하고 마지막 줄에서 '''로 닫습니다.
        """
        """* 이처럼 여러 줄로 된 문자열은 '''(작은따옴표 3개)로 시작하여 '''로 끝납니다. 물론 '''(큰따옴표 3개)로 시작하여 '''로 끝내도 됩니다.
        ### 문자열 안에 작은따옴표나 큰따옴표 포함하기
        * 그런데 문자열을 표현할 때 작은따옴표와 큰따옴표 중 한 가지로 통일하지 않고 여러 가지 방식을 사용할까요?
        * 문자열을 사용하다 보면 문자열 안에 작은따옴표나 큰따옴표를 넣어야 할 경우가 생깁니다. 이때는 작은따옴표와 큰따옴표를 사용하는 규칙이 달라집니다.
        """
        # 먼저 문자열 안에 '(작은따옴표)를 넣고 싶다면 문자열을 "(큰따옴표)로 묶어줍니다. 이렇게 하면 문자열 안에 '를 그대로 사용할 수 있습니다.
        # 반대로 문자열 안에 "(큰따옴표)를 넣고 싶다면 문자열을 '(작은따옴표)로 묶어줍니다.
        # 하지만 작은따옴표 안에 작은따옴표를 넣거나 큰따옴표 안에 큰따옴표를 넣을 수는 없습니다.
        # 하지만 여러 줄로 된 문자열은 작은따옴표 안에 작은따옴표와 큰따옴표를 둘 다 넣을 수 있습니다.
        # 또한, 큰따옴표 안에도 작은따옴표와 큰따옴표를 넣을 수 있습니다.
        """### 문자열에 따옴표를 포함하는 다른 방법
        * 작은따옴표 안에 작은따옴표를 넣을 수는 없을까요? 방법이 있습니다. 다음과 같이 작은따옴표 앞에 \(역슬래시)를 붙이면 됩니다.
        """
        """* 물론 큰따옴표도 "He said \"Python is easy\""처럼 큰따옴표 앞에 \를 붙이면 됩니다.
        * 이처럼 문자열 안에 ', " 등의 특수 문자를 포함하기 위해 앞에 \를 붙이는 방법을 이스케이프(escape)라고 부릅니다.
        """
        # 리스트와 튜플
        ## 리스트
        # 지금까지 변수에는 값을 한 개씩만 저장했습니다.
        """* 그럼 값을 30개 저장하려면 어떻게 해야 할까요? 다음과 같이 변수 30개에 값 30개를 저장하면 됩니다.
        ```
        a1 = 10
        a2 = 20
        # ... (생략)
        a29 = 60
        a30 = 40
        ```
        * 변수 30개를 일일이 타이핑하기는 쉽지 않습니다. 만약 저장할 값이 3,000개라면 정말 끔찍하죠? 이때는 리스트를 사용하면 편리합니다. 리스트는 말 그대로 목록이라는 뜻이며 값을 일렬로 늘어놓은 형태입니다(보통 리스트의 값은 코드로 생성하는 경우가 많아서 타이핑할 일이 거의 없습니다).
        ### 리스트 만들기
        * 변수에 값을 저장할 때 `[ ](대괄호)`로 묶어주면 리스트가 되며 각 값은 ,(콤마)로 구분해줍니다.
        * `리스트 = [값, 값, 값]`
        """
        """* 변수에 [ ]로 값을 저장하여 리스트를 만들었습니다. 특히 리스트에 저장된 각 값 요소(element)라고 부릅니다.
        ### 리스트에 여러 가지 자료형 저장하기
        * 리스트는 문자열, 정수, 실수, 불 등 모든 자료형을 저장할 수 있으며 자료형을 섞어서 저장해도 됩니다
        """
        """* 이처럼 리스트에 여러 가지 자료형을 사용하면 관련 정보를 하나로 묶기 좋습니다.
        ### 빈 리스트 만들기
        * 빈 리스트를 만들 때는 [ ]만 지정하거나 list를 사용하면 됩니다.
        * `리스트 = []`
        * `리스트 = list()`
        """
        """* 빈 리스트는 쓸모가 없을 것 같지만, 보통 빈 리스트를 만들어 놓은 뒤에 새 값을 추가하는 방식으로 사용합니다.
        ### range를 사용하여 리스트 만들기
        * 이번에는 range를 사용하여 리스트를 만들어보겠습니다. range는 연속된 숫자를 생성하는데 range에 10을 지정하면 0부터 9까지 숫자를 생성합니다. 즉, 지정한 횟수 숫자는 생성되는 숫자에 포함되지 않습니다.
        * `range(횟수)`
        """
        """* range(0, 10)이라고 나와서 10까지 생성될 것 같지만 10은 포함되지 않습니다. 다음과 같이 list에 range(10)을 넣어보면 0부터 9까지 들어있는 리스트가 생성됩니다.
        * `리스트 = list(range(횟수))`
        """
        """* range는 시작하는 숫자와 끝나는 숫자를 지정할 수도 있습니다. 이때도 끝나는 숫자는 생성되는 숫자에 포함되지 않습니다. 즉, list에 range(5, 12)를 넣으면 5부터 11까지 들어있는 리스트가 생성됩니다.
        * `리스트 = list(range(시작, 끝))`
        """
        """* 이번에는 증가폭을 사용하는 방법입니다. range에 증가폭을 지정하면 해당 값만큼 증가하면서 숫자를 생성합니다.
        * `리스트 = list(range(시작, 끝, 증가폭))`
        """
        """* range(-4, 10, 2)는 -4부터 8까지 2씩 증가합니다. 여기서 끝나는 값은 10이므로 10까지 증가하지 않고 8까지 생성됩니다.
        * 만약 증가폭을 음수로 지정하면 해당 값만큼 숫자가 감소합니다.
        """
        """## 튜플
        지금까지 리스트를 사용해보았는데 파이썬에서는 튜플이라는 자료형도 제공합니다. 튜플은 리스트처럼 요소를 일렬로 저장하지만, 안에 저장된 요소를 변경, 추가, 삭제를 할 수 없습니다. 간단하게 읽기 전용 리스트라고 할 수 있죠
        변수에 값을 저장할 때 ( )(괄호)로 묶어주면 튜플이 되며 각 값은 ,(콤마)로 구분해줍니다. 또는, 괄호로 묶지 않고 값만 콤마로 구분해도 튜플이 됩니다.
        * `튜플 = (값, 값, 값)`
        * `튜플 = 값, 값, 값`
        """
        # 숫자가 5개 들어있는 튜플
        # 괄호를 사용하지 않고 튜플 만들기
        # 튜플도 리스트처럼 여러 자료형을 섞어서 저장해도 됩니다.
        """그런데 저장된 요소를 변경, 추가, 삭제할 수도 없는 튜플을 왜 만들어 놓았을까요? 이유는 간단합니다. 파이썬 프로그래밍에서 튜플을 사용하는 쪽이 더 유리한 경우도 있기 때문입니다. 보통 튜플은 요소가 절대 변경되지 않고 유지되어야 할 때 사용합니다.
        튜플을 만든 상태에서 요소를 변경하게 되면 에러가 발생하게 됩니다. 따라서 요소를 실수로 변경하는 상황을 방지할 수 있습니다.
        반면 요소를 자주 변경해야 할 때는 리스트를 사용합니다. 보통 실무에서는 요소를 변경하는 경우가 많기 때문에 튜플보다 리스트를 더 자주 사용하는 편입니다.
        ### range를 사용하여 튜플 만들기
        """
        # 다음과 같이 tuple 안에 range를 넣으면 튜플이 생성됩니다.
        """range에 시작하는 숫자와 끝나는 숫자를 지정해서 튜플을 만들 수도 있겠죠? 다음은 5부터 11까지 들어있는 튜플을 만듭니다.
        * `튜플 = tuple(range(시작, 끝))`
        """
        """range에 증가폭을 지정하는 방법도 가능합니다.
        * `튜플 = tuple(range(시작, 끝, 증가폭))`
        """
        """### 튜플을 리스트로 만들고 리스트를 튜플로 만들기
        튜플과 리스트는 요소를 변경, 추가, 삭제할 수 있는지 없는지만 다를 뿐 기능과 형태는 같습니다. 따라서 튜플을 리스트로 만들거나 리스트를 튜플로 만들 수도 있습니다.
        """
        """반대로 list 안에 튜플을 넣으면 새 리스트가 생성됩니다."""
        """## 리스트와 튜플로 변수 만들기"""
        # 리스트와 튜플을 사용하면 변수 여러 개를 한 번에 만들 수 있습니다.
        # 이때 변수의 개수와 리스트(튜플)의 요소 개수는 같아야 합니다.
        # 리스트와 튜플 변수로도 변수 여러 개를 만들 수 있습니다.
        # 다음과 같이 리스트와 튜플의 요소를 변수 여러 개에 할당하는 것을
        # 리스트 언패킹(list unpacking), 튜플 언패킹(tuple unpacking)이라고 합니다.
        # 리스트 패킹(list packing)과 튜플 패킹(tuple packing)은
        # 변수에 리스트 또는 튜플을 할당하는 과정을 뜻합니다.

    def Python_Basic_01(self):
        # 시퀀스 자료형

        # 리스트, 튜플, 문자열, range. -> 공통점. -> 값이 연속적(sequence)으로 이어져 있다
        # 값이 연손적으로 이어진 자료형(자료의 형태, 자료가 저장된 방식)을 시퀀스 자료형(sequence type)

        print('파이썬', '파', '이', '썬')  # 단어들이 합쳐진 것 -> 문자열

        # 시퀀스 자료형이 공통 기능(특징)
        ## 검색 기능

        ## 특정한 값이 (안에) 있는지 확인
        ## -> 요소(element) -> 묶음 안에 존재하는지를 확인
        ## 값 in 시퀀스객체 : 있다
        ## 값 not in 시퀀스객체 : 없다
        ## 객체 : 특정한 자료형타입에 속하는 것들 -> 객체

        shoes = ["아디다스", "나이키", "뉴발란스"]
        print("shoes", shoes)
        print("'아디다스' in shoes :", '아디다스' in shoes)  # in도 일종의 연산자, 있으면 True...
        print("'프로스펙스' in shoes :", '프로스펙스' in shoes)  # 없으면? False
        print("'푸마' not in shoes :", '푸마' not in shoes, not '푸마' in shoes)  # in이 먼저 연산 처리 -> not. not in. not ~ in.

        # 시퀀스 타입(자료형)의 속하는 시퀀스 객체들의 공통적인 기능.
        # 시퀀스 타입 ⊃ (문자열, 리스트, 튜플, 레인지)
        t = ("마제소바", "토리동", "부타동", "점보부타동", "반숙계란")
        print("t :", t)  # 튜플
        print("'쌀국수' in t :", '쌀국수' in t)
        r = range(500, 100, -25)
        print("r :", list(r))
        print("200 not in r :", 200 not in r)
        print("(225, 200) not in r :", (225, 200) not in r)
        # 문자열 검색
        phone_number = "010-9999-9999"
        print('"0" in phone_number', "0" in phone_number)
        print('"010" in phone_number', "010" in phone_number)
        print('"011" in phone_number', "011" in phone_number)
        # 문자열은 연속된 부분집합의 형태로 단어들을 검색 (다른 시퀀스는 안됨)

        ## 연결(concatenate)
        # 시퀀스 객체는 + 연산자를 이용하여서 객체를 서로 연결하여 새 객체를 만들 수 있음
        # 시퀀스 객체 1 + 시퀀스 객체 2 (웬만하면 동일 타입... 그런데 강제로 붙이면 연결되기도 함...)
        # a = [0, 1, 2, 3] ~ 100단위가 넘어가면?
        # a = list(range(4))
        a = list(range(100))
        # b = [4, 5, 6, 7]
        # b = list(range(4, 8))
        b = list(range(40, 80, 7))
        # c = [0, 1, 2, 3, 4, 5, 6, 7]
        print("a + b :", a + b)
        # 튜플
        # a = ("a", "b", "c", "d")
        a = tuple("abcd")  # list("abcd")
        # b = ("e", "f", "g", "h")
        b = tuple("efgh")  # list("efgh")
        print("a + b :", a + b)

        # 시퀀스 자료형 중에 연결 안되는 것 : range가 연결이 안됨.
        # 잘 연결되는지 검사할 바에야 아예 막자
        # print(range(10) + range(10, 20)) : unsupported operand type(s) for +: 'range' and 'range'
        # range(7, 10) + range(100, 20, -1)
        print(list(range(10)) + list(range(10, 20)))

        # 문자열도 시퀀스도 -> 연결(+)
        # greeting = "안녕하세요! "
        # my_name = input("당신의 이름 : ")
        # print(greeting + my_name)

        # 문자열과 숫자 연결
        # money = input("받고 싶은 돈 : ")
        # print(type(money))
        # money = int(input("받고 싶은 돈 : "))
        # print(type(money))
        # # print("당신의 계좌에 " + money + "만원이 입금 되었습니다!")
        # # can only concatenate str (not "int") to str -> 문자열은 문자열 끼리만 연결할 수 있다 (int는 str 아님)
        # print("당신의 계좌에 " + str(money) + "만원이 입금 되었습니다!")

        ## 반복

        # * 연산자는 시퀀스 객체를 특정 횟수만큼 반복하여 시퀀스 객체를 만듭니다 (0이나 음수를 넣으면 빈 것이 나옴)
        '''
        - 시퀀스객체 * 정수
        - 정수 * 시퀀스객체
        '''
        k = [0, 10, 20, 30]
        print("k를 3번 반복한다", k + k + k)
        print("k를 3번 반복한다", k * 3)
        print("k를 0번 반복한다", k * 0)  # 음수는 빈 시퀀스.
        # 튜플도 유사...
        k *= 3
        print(k)  # 산술할당연산자 됨 (연결도 똑같이 됨)
        # range는 안 됨 -> list 또는 tuple로 변환해서...
        # print(range(10) * 3)
        print(tuple(range(10)) * 3)

        hello = "안녕"
        print(hello * 100)  # 문자열도 *을 통해서 반복 가능

        ## 길이 구하기
        ## 시퀀스 객체의 요소(element) 개수 구하기
        ## len -> length의 약자. 파이썬의 len은 함수. len(....)
        ## 길이 -> 객체에 딸린 메소드/함수 -> length, size... (다른 언어)
        ## len(시퀀스객체)

        a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]  # 피보나치 수열
        print(len(a))
        b = ("a", 1, True, 1.5)  # 4개
        print(len(b))  # 원소는 각각 1개로 무조건 카운팅

        # range : range에 len 함수를 사용하면 숫자가 생성되는 개수를 구합니다
        print(len(range(75, 20, -4)))

        # 문자열 : len -> 포함된 '문자' 개개의 갯수
        s = '오늘은 "점심"으로 \'마제소바\'를 먹을 것이다'  # 작은따옴표, 큰따옴표는 세지 X. (감싼). 공백(스페이스)는 1길이.
        # 파이썬은 숫자, 영어, 한글의 길이 구분 X -> 똑같이 길이 1씩.
        print(s)
        print(len(s))  # 25?

        # 인덱스
        # 시퀀스 객체 -> 여러 개의 데이터들이 묶여있는 형태. -> 순서가 정해져있음 (요소들간의)
        # -> 시퀀스 객체 내에 요소들의 위치 = 인덱스 (index)
        # 시퀀스_객체[인덱스번호] -> 시퀀스 개체에 [](대괄호)를 붙이고 [] 안에 각 요소의 인덱스(번호)를 지정하면 해당 요소에 접근(호출)
        a = [100, 200, 300, 400, 500]
        print(a[1])  # 200
        # 컴퓨터 프로그래밍에서는 모든 숫자 세기를 0부터 시작합니다.
        print(a[0])  # 100 -> 0이 순서 세기의 첫 번째.
        # 인덱스를 통해서 내가 원하는 값(특정한 순서에 있는 값)을 불러오는 것 : 인덱싱(indexing)
        print(a[2], a[4])
        print("len(a)", len(a))

        # print(a[5]) # IndexError: list index out of range -> index를 생각할 때 len보다 1 작은 것까지.

        b = (5, 13, 21, 34, 55)
        print("b[0]", b[0])
        print("b[3]", b[3])

        # range
        r = range(2, 5)  # 2, 3, 4
        print("r[2]", r[2])

        # 문자열 (string) -> 요소가 문자 한 개씩 끊긴 개념 -> 인덱스로 접근 -> 문자.
        s = "오늘의 날씨를 알려드리겠습니다"  # 8번째 요소를 출력한다
        print(s[8])  # 인덱스상 8 -> 9번째. ("알"
        print(s[7])  # 인덱스 7. (" ")

        print(s)  # 인덱스 없이 호출 -> 그 자체 (전체 값)
        # 해당 객체 전체

        # 음수 인덱스
        # - 인덱스 => 0 이상의 정수.
        # -> 음수 인덱스 (정수인데 -N)
        a = [38, 21, 3, 62, 19]
        print("a[-1]", a[-1])  # 맨 뒤에 있는 값
        print("a[-3]", a[-3])
        # -n 이라는 인덱스를 주면, 뒤에서부터 세서 위치
        # print("a[-6]", a[-6])
        print(a[len(a) - 1])  # len보다 음수 인덱스가 커지면 에러
        # 튜플, 레인지...
        s = "마제소바"
        print(s[-1])
        sn = "991111-1234567"
        print(sn[-7])

        # 인덱스를 통해 요소에 값 할당(대입) == 수정
        print(a)
        print(a[0])  # 시퀀스객체[인덱스] <- 그 값을 불러오는 기능 / 그 값의 위치를 확인.

        b = [0] * 5
        print("b", b)
        b[0] = 137
        b[1] = 44
        b[2] = 9
        b[3] = 13
        b[4] = 88
        # b[5] = 11231231 # IndexError: list assignment index out of range
        print("b", b)

        # 인덱스를 통해서 요소의 값을 재할당 -> 리스트.
        # 튜플, range, 문자열은 재할당 X - read-only
        t = (1, 2, 3)
        # t[1] = 5 # 2 -> 5
        # print(t)

        r = range(10)
        # r[0] = 9 # TypeError: 'range' object does not support item assignment

        s = "문자열"
        # s[0] = "곰" # 'str' object does not support item assignment

        # 요소 삭제 (요소 수정과 삭제 모두 리스트 전용 기능)

        a = ["바나나", "키위", "콩"]  # 0, 1, 2 -> '2'
        print(a)
        del a[2]
        print(a)
        # 튜플, 레인지, 문자열 -> 안먹힘.

    def Python_Basic_02(self):
        # 슬라이싱
        # 슬라이스 (slice)
        # 시퀀스 자료형 -> 슬라이스 (slice) -> 무엇인가의 일부를 잘라낸다 -> 시퀀스 슬라이스 -> 시퀀스 객체의 일부를 잘라내는 것
        # * 시퀀스객체[시작인덱스:끝인덱스]
        a = list(range(0, 100, 10))
        print(a)
        print(a[3:8])  # 시작인덱스는 포함, 끝 인덱스는 포함하지 X <- range랑 비슷하구나...
        print(a)
        # 끝인덱스는 가져오려는 범위에 포함되지 X -> 실제로 가져오려는 인덱스보다 1 더 크게 지정.
        print(len(a))  # 10 -> 인덱스? 9.
        print(a[0:10])  # 인덱스의 범위를 벗어나서 호출 가능. (끝점이 미포함이라서...)
        print(a[0:100])  # 시작점X. 끝점은 벗어나도 어차피 호출할 수 있는 건 정해져있어... 끝점은 len을 벗어나도 괜찮아요.
        print()
        print(a[0])  # 원소(요소) <-> 리스트 X.
        print(a[0:1])  # 시퀀스[idx:idx+1] -> idx의 인덱스의 값만 가진 시퀀스.
        print(a[1:1])  # 빈 값.

        # 음수 인덱스 -> 슬라이스.
        # 음수 인덱스 => len(...) - n.
        print("a[4:-1] :", a[4:-1])
        print("a[4:len(a)-1] :", a[4:len(a) - 1])
        print("a[-3:-1] :", a[-3:-1])

        # 슬라이스 -> range랑 닮았다 (증가폭? 증감폭?)
        print(a)
        print(a[4:7])
        print(a[4:7:1])  # 1? -> 인덱스를 1씩 증가하면서 복사해주겠다 -> 끝점 직전까지.
        print(a[4:10:2])  # 2? -> 인덱스를 2씩 증가하면서 복사해주겠다 -> 끝점 직전까지.
        print(a[7:4:-1])  # -1을 넣게 되면? -> 뒤집혀서 들어간다.
        print(a[10:4:-2])  # -2

        # 슬라이스에서 인덱스 생략
        '''
        슬라이스를 사용할 때 시작 인덱스와 끝 인덱스를 (둘 중하나 혹은 둘 다) 생략할 수 있음.
        인덱스 생략 -> 시퀀스 전체의 길이를 몰라도 -> 끝까지 지정.
        * 시퀀스객체[:끝인덱스] : 0번째 ~ 끝 인덱스 직전까지 / (0)
        * 시퀀스객체[시작인덱스:] : 시작인덱스 ~ 나머지 전체 / (len(시퀀스객체))
        '''
        print("a", a)
        print("a[0:7]", a[0:7])
        print("a[:7]", a[:7])
        print("a[4:len(a)]", a[4:len(a)])
        print("a[4:]", a[4:])
        print("a[:]", a[:], "a", a)
        print("a[0:len(a)]", a[0:len(a)])

        # 증가폭 사용시 생략을 할 때
        '''
        * 시퀀스객체[:끝인덱스:증가폭]
        * 시퀀스객체[시작인덱스::증가폭]
        * 시퀀스객체[::증가폭] *** = 0:len(시퀀스):증가폭.
        * 시퀀스객체[::] = 시퀀스객체[:] = 시퀀스객체
        '''
        print(a[::2])  # 2의 배수의 인덱스를 지닌 값들을 조회
        print(a[::-1])  # len(시퀀스):전체:-1 => 전체가 뒤집힌 값으로 제공
        # 튜플, 문자열, 레인지도...

        text = "사자는 오늘도 고기를 먹습니다"
        print(text[::-1])
        print(text[::2])
        print(text[2:4])

    def Python_Basic_03(self):
        # 딕셔너리 (Dictionary)
        warrior = [500, 100, 10.5, 27]  # 인덱스? -> 특정한 값에 대해서 설명? X -> 그저 위치
        print(warrior)
        # 해시맵, 맵, 오브젝트, 딕셔너리 ... -> 값들 묶음에서 -> 그 값이 어떠한 특징 혹은 속성인지에 대한 설명.
        warrior = {
            "hp": 500,
            "mp": 100,
            "atk": 10.5,
            "def": 27,
        }  # 사전을 찾듯이 어떠한 키(찾는 단어) -> 대응되는 값.
        print(warrior)

        # 딕셔너리 만들기
        '''
        * 딕셔너리 = {키1: 값1, 키2: 값2...} # 키는 겹치면 X. 수정할 수 없는 값. 각 키와 값 쌍 콤마(,)로 구분 
        '''
        kim = {
            "name": "춘식",  # key:value,
            "age": 25,  # key:value,
            "marry": False,  # ...
        }
        # 키에는 값을 하나만 지정할 수 있음 -. 키-값 쌍(key-value pair)
        lee = {
            "name": "봉식",
            "name": "봉구",  # 같은 딕셔너리 안에서 마지막으로 key에 대입된 값이 최종 값.
        }
        print(lee)

        print(lee['name'])  # 각각의 키가 value를 불러낼 수 있는 열쇠.

        # 딕셔너리 키의 자료형
        # key -> 문자열. 이 외에도 '수정되지 않는 값'은 모두 key로 쓸 수 있음.
        # (1) 리스트 (2) 딕셔너리 -> 나머지 웬만한 기본적인 자료형들은 key로 쓸 수 있음
        # bool, int, float, tuple, range, 문자열... -> key로 쓸 수 있음.
        # 굳이 리스트를 key로 쓰고 싶다 tuple로 감싸서 튜플화시켜서 쓰면 됨.

        # 딕셔너리 키에 접근 및 할당
        # 리스트의 경우 -> 리스트[인덱스] -> 값. 리스트[인덱스] = 새로운 값 => 할당.
        # 리스트-인덱스, 딕셔너리-키. => 호출 시 리스트의 원소를 인덱스로 호출 하는 것 처럼, 딕셔너리의 값은 키로 호출할 수 있다 + 할당.
        park = {
            "address": "여의도"
        }
        print("park[\"address\"]", park["address"])
        park['address'] = "일산"  # 할당 연산자 -> 새로운 값을 대입(할당) -> 변수, 리스트[인덱스] = 새로운 값...
        print("park[\"address\"]", park["address"])
        # 키를 지정하지 않고 그냥 dictionary를 호출하면?
        print(park)  # key-value 쌍이 들어있는 딕셔너리 자체

        # 빈 딕셔너리 만들기
        # 빈 리스트 -> list() 혹은 [] -> 변수.
        x = {}  # {}를 넣어서 혹은
        x = dict()  # dict()를 통해서 만들어주게 됨
        print(x)

        # print(park['car']) # 없는 키를 호출하게 되면? # KeyError: 'car' -> 없어서 에러가 남
        # key라고 하는 거는, 딕셔너리를 만들 때 넣어주거나, 아니면 할당할 때 쉽게 넣고 할 수 있는데...
        # 아예 할당되지 않은 키는 조회시 에러가 발생
        x['car'] = '모닝'  # 할당 -> 문제 없음 (<-> 리스트는 없는 인덱스에는 추가하면서 생성 X)s
        print(x)

        # 딕셔너리에 키가 있는지 확인
        # 시퀀스 -> '안'에 특정한 요소/값이 있는지 확인하려면? in.
        # 딕셔너리도 같은 걸 쓰는데... 키만 확인.
        data = {
            "kim": 200,
            "park": 300,
        }
        print(data)
        print('"kim" in data', "kim" in data)  # 특정한 Key가 존재하는지
        '''
        * 키 in 딕셔너리
        '''
        print('"lee" in data', "lee" in data)  # 특정한 Key가 존재하는지
        print('not "lee" in data', not "lee" in data)  # 특정한 Key가 존재하는지 -> not을 통해서 뒤집기
        print('"lee" not in data', "lee" not in data)  # 특정한 Key가 존재하지 않는지

        d = {
            "scores": [1, 2, 3],  # 키-값 : 1씩
            "money": 100  # 키-값 : 1씩
        }
        d['hello'] = True
        print(d)
        print(len(d))  # 키의 갯수를 세어줌 근데 키-값은 1:1 대응이니까, 값의 갯수를 세주는 겸.

    def Python_Basic_04(self):
        # 조건문
        # 조건문 -> 특정 조건을 만족시켰을 때 실행시키는 문법
        # -> 특정 조건을 만족시킨다? -> True가 나오면.(계산, 실행 => 그 결과가 True다 => 만족시켰다)
        # -> bool, 비교연산자, 논리연산자...

        '''
        # if 조건문. ~ 3.7? 3.9? => if조건문.
        if 조건식:
            조건을 만족시켰을 때 실행할 코드
        '''

        # my_age = int(input("당신의 나이는? : "))
        # if my_age > 20: # my_age > 20 : 비교연산자 (True)
        #     # 들여쓰기 된 내부의 코드를 실행 (if와 :(콜론) 사이의 특정한 조건을 만족시키면...)
        #     print("술과 담배가 가능합니다!")

        # if my_age > 20:
        # print("술과 담배가 가능합니다!") # IndentationError: expected an indented block after 'if' statement on line 17

        # 중첩 if문
        # if my_age < 20:
        #     print("학생입니다!")
        #     if my_age >= 17: # 새로운 if문을 열면 -> 새로운 들여쓰기
        #         print("고등학생입니다!")
        #     if my_age < 17 and my_age >= 14: # 논리연산자를 통해서
        #         print("중학생입니다!")

        # else
        '''
        if A: # 이것을 만족(True <-> False)시킬 때 <- 이 전화는 광고전화인가?
            ... (A - 나이가 성인인가?)
            끊고, 차단한다
        else:
            ...? (성인이 아니라면?)
            받고 이야기를 나눈다
        '''
        '''
        if <조건식>:
            코드1
        else: # 단독으로 올 수 없음?
            코드2
        '''

        # if my_age > 20:
        #     print("복권을 구입할 수 있습니다")
        # else:
        #     print("복권을 구입할 수 없습니다") # 들여쓰기 주의!!!

        # 조건문에 다양한 자료형 넣어보기

        # 불(bool) -> 숫자는 0이 아니면 -> True. (0만 False) - 정수, 실수.
        # 글자는 ""가 아니면 -> True. -> len(시퀀스) == 0 -> False, len(시퀀스) != 0 -> True
        print("bool(1)", bool(1))
        print("bool(0)", bool(0))
        print("bool(-1)", bool(-1))
        print("bool('False')", bool('False'))  # 시퀀스 -> len -> 빈 문자열 -> len(문자열) == 0
        print("bool('')", bool(''))  # False => len(문자열) != 0
        print("bool([])", bool([]))
        print("bool([False])", bool([False]))

        if 1:  # bool로 알아서 바꿔줌 -> bool(...) 씌운 효과
            # if True:
            print("??????")
        if 0:
            print("000000")
        if '':
            print("빈 문자열")
        if ' ':
            print("공백 문자열")
        if []:
            print("빈 리스트")
        if [False]:
            print("길이가 있는 리스트")

        # elif

        # if : 단순히 조건을 만족시키는 지 여부
        # if ... else : 만족할 때 / 만족하지 않을 때를 구분해서 배치.
        # 만약에 조건이 여러개면?
        menu = input("마시고 싶은 음료 : (아메리카노, 제로콜라, 물) ")
        # # ---
        # if menu == "아메리카노": # 각각 별도의 if문
        #     print("아메리카노 나왔습니다")
        # # ---
        # if menu == "제로콜라": # 각각 별도의 if문
        #     print("제로콜라 나왔습니다")
        # # ---
        # if menu == "물": # 각각 별도의 if문
        #     print("물 나왔습니다")
        # else:
        #     print("주문할 수 없는 음료입니다")
        # # ---
        # ---
        if menu == "아메리카노":  # 각각 별도의 if문
            print("아메리카노 나왔습니다")
        elif menu == "제로콜라":  # 각각 별도의 if문
            print("제로콜라 나왔습니다")
        elif menu == "물":  # 각각 별도의 if문
            print("물 나왔습니다")  # 실행문
        else:
            print("주문할 수 없는 음료입니다")
        # ---
        # elif는 단독으로 사용할 수 있다? 없다 => 맨 처음 if문이 있어야 elif가 붙을 수 있기 때문에.
        # elif는 추가적으로 들여쓰기할 필요가 있다? => 없다. 기본적인 코드블록의 들여쓰기만 하면 된다.